[
    {
		"Title":       "Two Sum",
		"Difficulty":  "Easy",
		"Description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
		"Hints": [
			"Use a hashmap to store each element's index and check if the complement exists.",
			"Consider edge cases such as no solution or multiple solutions."
        ],
		"Constraints": [
			"You may assume that each input would have exactly one solution.",
			"You may not use the same element twice.",
			"The order of the result does not matter."
        ]
	},
	{
		"Title":       "Add Two Numbers",
		"Difficulty":  "Medium",
		"Description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
		"Hints": [
			"Initialize a dummy head for the result list.",
			"Use a carry variable to keep track of the carry from the addition of each digit.",
			"Traverse both lists and add corresponding digits along with the carry."
        ],
		"Constraints": [
			"The number of nodes in each linked list is in the range [1, 100].",
			"0 <= Node.val <= 9",
			"It is guaranteed that the list represents a number that does not have leading zeros."
        ]
	},
	{
		"Title":       "Longest Substring Without Repeating Characters",
		"Difficulty":  "Medium",
		"Description": "Given a string s, find the length of the longest substring without repeating characters.",
		"Hints": [
			"Use a sliding window to keep track of the current substring without repeating characters.",
			"Use a hash map to store the last index of each character.",
			"Update the start of the window when a repeating character is found."
        ],
		"Constraints": [
			"0 <= s.length <= 5 * 10^4",
			"s consists of English letters, digits, symbols and spaces."
        ]
	},
	{
		"Title":       "Median of Two Sorted Arrays",
		"Difficulty":  "Hard",
		"Description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.",
		"Hints": [
			"Try to come up with a solution of logarithmic time complexity.",
			"Use binary search to partition the arrays such that the left part contains the smallest half of the elements.",
			"Ensure the partition is balanced to find the median."
        ],
		"Constraints": [
			"nums1.length == m",
			"nums2.length == n",
			"0 <= m <= 1000",
			"0 <= n <= 1000",
			"1 <= m + n <= 2000",
			"-10^6 <= nums1[i], nums2[i] <= 10^6"
        ]
	},
	{
		"Title":       "Longest Palindromic Substring",
		"Difficulty":  "Medium",
		"Description": "Given a string s, return the longest palindromic substring in s.",
		"Hints": [
			"Expand Around Center: You could use an approach that considers each character (and between characters) as the center of a potential palindrome and expand outwards.",
			"Dynamic Programming: Use a 2D table to keep track of palindromic substrings.",
			"Optimize with Manacher's Algorithm for linear time complexity."
        ],
		"Constraints": [
			"1 <= s.length <= 1000",
			"s consist of only digits and English letters."
        ]
	},
	{
		"Title":       "Zigzag Conversion",
		"Difficulty":  "Medium",
		"Description": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\nP   A   H   N\nA P L S I I G\nY   I   R\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:",
		"Hints": [
			"You can create an array of strings, one for each row.",
			"Iterate through the characters of the string, adding each character to the appropriate row.",
			"The pattern alternates between moving down and moving up."
        ],
		"Constraints": [
			"1 <= s.length <= 1000",
			"s consists of English letters (lower-case and upper-case), ',' and '.'.",
			"1 <= numRows <= 1000"
        ]
	},
	{
		"Title":       "Reverse Integer",
		"Difficulty":  "Medium",
		"Description": "Given a 32-bit signed integer, reverse digits of an integer.",
		"Hints": [
			"Think about how you would do it on paper.",
			"Ensure that your integer does not overflow when reversed."
        ],
		"Constraints": [
			"The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows."
        ]
	},
	{
		"Title":       "String to Integer (atoi)",
		"Difficulty":  "Medium",
		"Description": "Implement the `atoi` function, which converts a string to an integer.",
		"Hints": [
			"Consider all possible edge cases: whitespaces, signs, overflow, invalid characters, etc.",
			"You might want to use the `long` data type to handle overflow cases before clamping the result."
        ],
		"Constraints": [
			"The function discards all whitespace characters at the beginning of the string.",
			"The function processes an optional initial plus or minus sign followed by as many numerical digits as possible and interprets them as a numerical value.",
			"The function stops processing as soon as it encounters a non-numerical character.",
			"If the string is empty or does not contain valid digits, return 0.",
			"If the numerical value is out of the range of a 32-bit signed integer, clamp the value to the range [−2^31, 2^31 − 1]."
        ]
	},
	{
		"Title":       "Palindrome Number",
		"Difficulty":  "Easy",
		"Description": "Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.",
		"Hints": [
			"Negative numbers are not palindromes.",
			"Reverse the number and compare it with the original number."
        ],
		"Constraints": [
			"Follow up: Could you solve it without converting the integer to a string?"
        ]
	},
	{
		"Title":       "Regular Expression Matching",
		"Difficulty":  "Hard",
		"Description": "Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.",
		"Hints": [
			"Consider the cases for '.' and '*'.",
			"Dynamic Programming (DP) can be useful here."
        ],
		"Constraints": [
			"The input strings consist of only lowercase English letters.",
			"The length of both strings s and p is <= 20.",
			"It is guaranteed that s and p are non-empty."
        ]
	},
	{
		"Title":       "Container With Most Water",
		"Difficulty":  "Medium",
		"Description": "Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.",
		"Hints": [
			"The aim is to maximize the area formed between the vertical lines.",
			"Start with two pointers approach."
        ],
		"Constraints": [
			"n == height.length",
			"2 <= n <= 10^5",
			"0 <= height[i] <= 10^4"
        ]
	},
	{
		"Title":       "Integer to Roman",
		"Difficulty":  "Medium",
		"Description": "Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.",
		"Hints": [
			"Start with the largest value and reduce the problem to smaller subproblems.",
			"Use predefined mappings of roman numeral symbols to integers."
        ],
		"Constraints": [
			"1 <= num <= 3999"
        ]
	},
	{
		"Title":       "Roman to Integer",
		"Difficulty":  "Easy",
		"Description": "Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.",
		"Hints": [
			"Use a hashmap to store the mapping of roman numerals to integers.",
			"Iterate through the string and compare current and next characters to determine the integer value."
        ],
		"Constraints": [
			"1 <= s.length <= 15",
			"s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').",
			"It is guaranteed that s is a valid roman numeral in the range [1, 3999]."
        ]
	},
	{
		"Title":       "Longest Common Prefix",
		"Difficulty":  "Easy",
		"Description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".",
		"Hints": [
			"Start with the first string as the initial prefix candidate.",
			"Compare this prefix candidate with each subsequent string, updating the prefix candidate as you find common prefixes."
        ],
		"Constraints": [
			"1 <= strs.length <= 200",
			"0 <= strs[i].length <= 200",
			"strs[i] consists of only lower-case English letters."
        ]
	},
	{
		"Title":       "3Sum",
		"Difficulty":  "Medium",
		"Description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
		"Hints": [
			"Sort the array to use two pointers technique.",
			"Iterate through the array, using the current element as the first element of the triplet.",
			"Use two pointers to find the other two elements that sum up to the negative of the current element."
        ],
		"Constraints": [
			"0 <= nums.length <= 3000",
			"-10^5 <= nums[i] <= 10^5"
        ]
	},
	{
		"Title":       "3Sum Closest",
		"Difficulty":  "Medium",
		"Description": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.",
		"Hints": [
			"Sort the array to use two pointers technique.",
			"Iterate through the array, using the current element as the first element of the triplet.",
			"Use two pointers to find the other two elements that sum up to the target minus the current element."
        ],
		"Constraints": [
			"3 <= nums.length <= 10^3",
			"-10^3 <= nums[i] <= 10^3",
			"-10^4 <= target <= 10^4"
        ]
	},
	{
		"Title":       "Letter Combinations of a Phone Number",
		"Difficulty":  "Medium",
		"Description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.",
		"Hints": [
			"Use backtracking to generate all possible combinations.",
			"Create a mapping from each digit to its corresponding letters on a phone keypad.",
			"Iterate through each digit in the input string and recursively generate combinations by appending each possible letter."
        ],
		"Constraints": [
			"0 <= digits.length <= 4",
			"digits[i] is a digit in the range ['2', '9']."
        ]
	},
	{
		"Title":       "4Sum",
		"Difficulty":  "Medium",
		"Description": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n1. 0 <= a, b, c, d < n\n2. a, b, c, and d are distinct.\n3. nums[a] + nums[b] + nums[c] + nums[d] == target\nYou may return the answer in any order.",
		"Hints": [
			"Sort the array, and use recursion with backtracking to find all unique quadruplets.",
			"Avoid duplicates by skipping identical numbers when iterating through the array."
        ],
		"Constraints": [
			"1 <= nums.length <= 200",
			"-10^9 <= nums[i] <= 10^9",
			"-10^9 <= target <= 10^9"
        ]
	},
	{
		"Title":       "Remove Nth Node From End of List",
		"Difficulty":  "Medium",
		"Description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
		"Hints": [
			"Use two pointers to find the nth node from the end in one pass.",
			"Handle edge cases where the list contains only one node or removing the first node."
        ],
		"Constraints": [
			"The number of nodes in the list is sz.",
			"1 <= sz <= 30",
			"0 <= Node.val <= 100",
			"1 <= n <= sz"
        ]
	},
	{
		"Title":       "Valid Parentheses",
		"Difficulty":  "Easy",
		"Description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
		"Hints": [
			"Use a stack to keep track of opening brackets.",
			"Iterate through the string, pushing opening brackets onto the stack and popping from the stack when encountering a closing bracket.",
			"Check if the stack is empty at the end to determine validity."
        ],
		"Constraints": [
			"1 <= s.length <= 104",
			"s consists of parentheses only '()[]{}'."
        ]
	},
	{
		"Title":       "Merge Two Sorted Lists",
		"Difficulty":  "Easy",
		"Description": "Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.",
		"Hints": [
			"Use a dummy node to simplify the code.",
			"Iterate through both lists and compare the values, appending the smaller value to the result list.",
			"Handle cases where one list is exhausted before the other."
        ],
		"Constraints": [
			"The number of nodes in both lists is in the range [0, 50].",
			"-100 <= Node.val <= 100",
			"Both l1 and l2 are sorted in non-decreasing order."
        ]
	},
	{
		"Title":       "Generate Parentheses",
		"Difficulty":  "Medium",
		"Description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
		"Hints": [
			"Think recursively: to generate parentheses for n pairs, you can add '(' or ')' as long as it doesn't exceed the count of each type.",
			"Use backtracking to explore all possible combinations, keeping track of the balance of '(' and ')'."
        ],
		"Constraints": [
			"1 <= n <= 8"
        ]
	},
	{
		"Title":       "Merge k Sorted Lists",
		"Difficulty":  "Hard",
		"Description": "Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.",
		"Hints": [
			"Use a min-heap to efficiently get the smallest element among all lists.",
			"Merge lists in a divide-and-conquer approach, reducing the number of lists to merge at each step until only one list remains."
        ],
		"Constraints": [
			"0 <= k <= 10^4",
			"0 <= lists[i].length <= 500",
			"-10^4 <= lists[i][j] <= 10^4",
			"lists[i] is sorted in ascending order.",
			"The sum of lists[i].length won't exceed 10^4."
        ]
	},
	{
		"Title":       "Swap Nodes in Pairs",
		"Difficulty":  "Medium",
		"Description": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed).",
		"Hints": [
			"If you swap nodes A and B, you need to make sure their previous node points to B instead of A, and B points to A instead of its next node.",
			"Handle edge cases such as an empty list or a list with only one node."
        ],
		"Constraints": [
			"The number of nodes in the list is in the range [0, 100].",
			"0 <= Node.val <= 100"
        ]
	},
	{
		"Title":       "Reverse Nodes in k-Group",
		"Difficulty":  "Hard",
		"Description": "Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k, then left-out nodes, in the end, should remain as it is.",
		"Hints": [
			"If you have less than k nodes left in the linked list, you should reverse them as well.",
			"Use recursion to solve the problem, breaking down the problem into smaller parts (reversing each k-group of nodes)."
        ],
		"Constraints": [
			"The number of nodes in the list is in the range sz.",
			"1 <= sz <= 5000",
			"0 <= Node.val <= 1000",
			"1 <= k <= sz"
        ]
	},
	{
		"Title":      "Remove Duplicates from Sorted Array",
		"Difficulty": "Easy",
		"Description": "\nGiven an integer array nums sorted in non-decreasing order, \nremove the duplicates in-place such that each unique element appears only once.\nThe relative order of the elements should be kept the same. \nThen return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need \nto do the following things:\n\nChange the array nums susersuch that the first k elements of nums contain\nthe unique elements in the order they were present in nums initially.\nThe remaining elements of nums are not important as well as the size of nums\nReturn k.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;for (int i = 0; i < k; i++) {    assert nums[i] == expectedNums[i];}\nIf all assertions pass, then your solution will be accepted.",
		"Hints": ["In this problem, the key point to focus on isthe input array being sorted. As far as duplicateelements are concerned, what is their positioning in the array when the given array is sorted? Look at the image below for the answer. If we know the position of one of the elements, do we also know the positioning of all the duplicate elements? ",
                "We need to modify the array in-place and \nthe size of the final array would potentially \nbe smaller than the size of the input array. So, we \nought to use a two-pointer approach here. One, that would \nkeep track of the current element in the original array and another \none for just the unique elements.", "Essentially, once an element is encountered, you simply\nneed to bypass its duplicates and move on to the next unique element."
        ],
		"Constraints": [
			"1 <= nums.length <= 3 * 104",
			"-100 <= nums[i] <= 100",
			"nums is sorted in non-decreasing order."
        ]
	},
	{
		"Title":       "Remove Element",
		"Difficulty":  "Easy",
		"Description": "Given an array nums and a value val, remove all instances of that value in-place and return the new length.",
		"Hints": [
			"The order of elements can be changed. It doesn't matter what you leave beyond the new length.",
			"Two pointers approach can be useful here."
        ],
		"Constraints": [
			"0 <= nums.length <= 100",
			"0 <= nums[i] <= 50",
			"0 <= val <= 100"
        ]
	},
	{
		"Title":       "Implement strStr()",
		"Difficulty":  "Easy",
		"Description": "Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.",
		"Hints": [
			"The naive approach is to check each substring of the haystack with the needle.",
			"Use the built-in string library functions in Go to implement this efficiently."
        ],
		"Constraints": [
			"0 <= haystack.length, needle.length <= 5 * 10^4",
			"haystack and needle consist of only lower-case English characters."
        ]
	},
	{
		"Title":       "Divide Two Integers",
		"Difficulty":  "Medium",
		"Description": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.",
		"Hints": [
			"Think about bit manipulation (shift operations).",
			"Consider edge cases like overflow and handling of negative numbers."
        ],
		"Constraints": [
			"-2^31 <= dividend, divisor <= 2^31 - 1",
			"divisor != 0"
        ]
	},
	{
		"Title":       "Substring with Concatenation of All Words",
		"Difficulty":  "Hard",
		"Description": "You are given a string s and an array of words words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters.",
		"Hints": [
			"Use a sliding window approach combined with a hash map to efficiently find the substrings.",
			"Consider the length of words and how they can concatenate in any order."
        ],
		"Constraints": [
			"1 <= s.length <= 10^4",
			"words.length <= 5000",
			"1 <= words[i].length <= 30"
        ]
	},
	{
		"Title":       "Next Permutation",
		"Difficulty":  "Medium",
		"Description": "Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).",
		"Hints": [
			"To generate the next permutation, you need to find the first pair of two successive numbers a[i] and a[i-1], from the right, which satisfy a[i] > a[i-1].",
			"Once the successor is found, the next step is to find the smallest number on right side of partion index which is greater than value found in previous step."
        ],
		"Constraints": [
			"1 <= nums.length <= 100",
			"0 <= nums[i] <= 100"
        ]
	},
	{
		"Title":       "Longest Valid Parentheses",
		"Difficulty":  "Hard",
		"Description": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.",
		"Hints": [
			"Use a stack to keep track of the indices of '(' characters.",
			"Scan the string from left to right and from right to left to find the longest valid substring."
        ],
		"Constraints": [
			"0 <= s.length <= 3 * 10^4",
			"s[i] is '(' or ')'."
        ]
	},
	{
		"Title":       "Search in Rotated Sorted Array",
		"Difficulty":  "Medium",
		"Description": "There is an integer array nums sorted in ascending order (with distinct values). Prior to being rotated at some unknown pivot, nums was originally a sorted ascending array. You are given a target value to search. If found in the array return its index, otherwise return -1.",
		"Hints": [
			"Consider using binary search for an efficient solution.",
			"Think about the conditions for determining whether to search left or right of the mid-point in the array."
        ],
		"Constraints": [
			"1 <= nums.length <= 5000",
			"-10^4 <= nums[i], target <= 10^4",
			"All values of nums are unique.",
			"nums is guaranteed to be rotated at some pivot."
        ]
	},
	{
		"Title":       "Find First and Last Position of Element in Sorted Array",
		"Difficulty":  "Medium",
		"Description": "Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. If the target is not found in the array, return [-1, -1].",
		"Hints": [
			"Consider using binary search to find the leftmost and rightmost positions of the target.",
			"Implement two separate binary searches for finding the starting and ending positions."
        ],
		"Constraints": [
			"0 <= nums.length <= 10^5",
			"-10^9 <= nums[i] <= 10^9",
			"nums is a non-decreasing array."
        ]
	},
	{
		"Title":       "Search Insert Position",
		"Difficulty":  "Easy",
		"Description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.",
		"Hints": [
			"Consider using binary search to find the insertion position efficiently.",
			"Handle edge cases such as the target being smaller or larger than any element in the array."
        ],
		"Constraints": [
			"1 <= nums.length <= 10^4",
			"-10^4 <= nums[i] <= 10^4",
			"nums is sorted in ascending order."
        ]
	},
	{
		"Title":       "Valid Sudoku",
		"Difficulty":  "Medium",
		"Description": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n\n1. Each row must contain the digits 1-9 without repetition.\n2. Each column must contain the digits 1-9 without repetition.\n3. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.",
		"Hints": [
			"Use sets or arrays to track the presence of numbers in rows, columns, and sub-boxes.",
			"Validate each row, column, and sub-box separately using nested loops."
        ],
		"Constraints": [
			"board.length == 9",
			"board[i].length == 9",
			"board[i][j] is a digit or '.'.",
			"It is guaranteed that the Sudoku board will be valid."
        ]
	},
	{
		"Title":       "Sudoku Solver",
		"Difficulty":  "Hard",
		"Description": "Write a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy all of the following rules:\n\n1. Each of the digits 1-9 must occur exactly once in each row.\n2. Each of the digits 1-9 must occur exactly once in each column.\n3. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n\nThe '.' character indicates empty cells.",
		"Hints": [
			"Use backtracking to explore all possibilities.",
			"Implement functions to check the validity of placing a number in a specific cell based on row, column, and 3x3 sub-box 'Constraints'."
        ],
		"Constraints": [
			"board.length == 9",
			"board[i].length == 9",
			"board[i][j] is a digit or '.'.",
			"It is guaranteed that the Sudoku puzzle will have a single unique solution."
        ]
	},
	{
		"Title":       "Count and Say",
		"Difficulty":  "Easy",
		"Description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\n1. countAndSay(1) = '1'\n2. countAndSay(n) is the way you would 'say' the digit string from countAndSay(n-1), which is then converted into a different representation.\n\nTo determine how you 'say' a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.\n\nFor example, the saying and conversion for digit string '3322251' is '2 3 3 2 2 1' ('two 3s, two 2s, then one 1').",
		"Hints": [
			"Use iterative approach to generate the next sequence based on the previous one.",
			"Consider using two pointers to traverse and count consecutive characters in the string."
        ],
		"Constraints": [
			"1 <= n <= 30"
        ]
	},
	{
		"Title":       "Combination Sum",
		"Difficulty":  "Medium",
		"Description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.",
		"Hints": [
			"Use backtracking to explore all possible combinations.",
			"Sort the candidates array to handle duplicates easily and improve efficiency."
        ],
		"Constraints": [
			"1 <= candidates.length <= 30",
			"1 <= candidates[i] <= 200",
			"All elements of candidates are distinct.",
			"1 <= target <= 500"
        ]
	},
	{
		"Title":       "Combination Sum II",
		"Difficulty":  "Medium",
		"Description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n\nEach number in candidates may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.",
		"Hints": [
			"Use backtracking to explore all possible combinations.",
			"Sort the candidates array to handle duplicates easily and improve efficiency."
        ],
		"Constraints": [
			"1 <= candidates.length <= 100",
			"1 <= candidates[i] <= 50",
			"1 <= target <= 30"
        ]
	},
	{
		"Title":       "First Missing Positive",
		"Difficulty":  "Hard",
		"Description": "Given an unsorted integer array nums, return the smallest missing positive integer.\n\nYou must implement an algorithm that runs in O(n) time and uses constant extra space.",
		"Hints": [
			"Think about how to make use of the array itself to store information.",
			"Consider using a cyclic sort approach."
        ],
		"Constraints": [
			"1 <= nums.length <= 5 * 10^5",
			"-2 * 10^9 <= nums[i] <= 2 * 10^9"
        ]
	},
	{
		"Title":       "Trapping Rain Water",
		"Difficulty":  "Hard",
		"Description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\nThe height at each index i represents the elevation of the terrain at that point. The width of each bar is 1.\n\n'Constraints':\n\nn == height.length\n0 <= n <= 3 * 10^4\n0 <= height[i] <= 10^5",
		"Hints": [
			"Try to solve it with two pointers.",
			"Simulate the process of water flowing from the highest point to both ends."
        ],
		"Constraints": [
			"1 <= n <= 3 * 10^4",
			"0 <= height[i] <= 10^5"
        ]
	},
	{
		"Title":       "Multiply Strings",
		"Difficulty":  "Medium",
		"Description": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.",
		"Hints": [
			"Use an array to store intermediate results of multiplication.",
			"Consider how traditional multiplication works with pen and paper."
        ],
		"Constraints": [
			"1 <= num1.length, num2.length <= 200",
			"num1 and num2 consist of digits only.",
			"Both num1 and num2 do not contain any leading zero, except the number 0 itself."
        ]
	},
	{
		"Title":       "Wildcard Matching",
		"Difficulty":  "Hard",
		"Description": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.\n\n'?' Matches any single character.\n'*' Matches any sequence of characters (including the empty sequence).\nThe matching should cover the entire input string (not partial).\n\n'Constraints':\n\n0 <= s.length, p.length <= 2000\ns contains only lowercase English letters.\np contains only lowercase English letters, '?' or '*'.",
		"Hints": [
			"Dynamic programming approach can be used to solve this problem efficiently.",
			"Consider how '?' and '*' can be handled in the matching process."
        ],
		"Constraints": [
			"0 <= s.length, p.length <= 2000",
			"s contains only lowercase English letters.",
			"p contains only lowercase English letters, '?' or '*'."
        ]
	},
	{
		"Title":       "Jump Game II",
		"Difficulty":  "Hard",
		"Description": "Given an array of non-negative integers nums, you are initially positioned at the first index of the array.\n\nEach element in the array represents your maximum jump length at that position.\n\nYour goal is to reach the last index in the minimum number of jumps.\n\nYou can assume that you can always reach the last index.",
		"Hints": [
			"Use a greedy approach to track the furthest point you can reach with the current number of jumps.",
			"Consider how to optimize the jumps needed using the maximum reach strategy."
        ],
		"Constraints": [
			"1 <= nums.length <= 1000",
			"0 <= nums[i] <= 10^5"
        ]
	},
	{
		"Title":       "Permutations",
		"Difficulty":  "Medium",
		"Description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
		"Hints": [
			"Backtracking is an efficient way to solve this problem.",
			"Think about how to swap elements to generate different permutations."
        ],
		"Constraints": [
			"1 <= nums.length <= 6",
			"-10 <= nums[i] <= 10",
			"All the integers of nums are unique."
        ]
	},
	{
		"Title":       "Permutations II",
		"Difficulty":  "Medium",
		"Description": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.",
		"Hints": [
			"Use a similar approach to generate permutations as in the previous problem, but handle duplicates carefully.",
			"Consider how to skip duplicates to generate unique permutations."
        ],
		"Constraints": [
			"1 <= nums.length <= 8",
			"-10 <= nums[i] <= 10"
        ]
	},
	{
		"Title":       "Rotate Image",
		"Difficulty":  "Medium",
		"Description": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.",
		"Hints": [
			"To rotate the matrix in-place, consider how elements move during rotation.",
			"Think about how to transpose the matrix and then reverse each row to achieve the rotation."
        ],
		"Constraints": [
			"matrix.length == n",
			"matrix[i].length == n",
			"1 <= n <= 20",
			"-1000 <= matrix[i][j] <= 1000"
        ]
	},
	{
		"Title":       "Group Anagrams",
		"Difficulty":  "Medium",
		"Description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
		"Hints": [
			"Use a hash map to store groups of anagrams.",
			"Consider how to represent and compare anagrams efficiently."
        ],
		"Constraints": [
			"1 <= strs.length <= 10^4",
			"0 <= strs[i].length <= 100",
			"strs[i] consists of lower-case English letters."
        ]
	},
	{
		"Title":       "Pow(x, n)",
		"Difficulty":  "Medium",
		"Description": "Implement `pow(x, n)`, which calculates `x` raised to the power `n` (i.e., `x^n`).",
		"Hints": [
			"Consider how to optimize the calculation using recursion and divide-and-conquer techniques.",
			"Handle both positive and negative values of `n`."
        ],
		"Constraints": [
			"-100.0 < x < 100.0",
			"-2^31 <= n <= 2^31-1",
			"-10^4 <= x^n <= 10^4"
        ]
	},
	{
		"Title":       "N-Queens",
		"Difficulty":  "Hard",
		"Description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.",
		"Hints": [
			"Use backtracking to try placing queens row by row and backtrack when a conflict is found.",
			"Consider how to efficiently check conflicts for each placement of a queen."
        ],
		"Constraints": [
			"1 <= n <= 9"
        ]
	},
	{
		"Title":       "N-Queens II",
		"Difficulty":  "Hard",
		"Description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n\nGiven an integer n, return the number of distinct solutions to the n-queens puzzle.",
		"Hints": [
			"Use backtracking to try placing queens row by row and count valid solutions.",
			"Consider how to efficiently check conflicts for each placement of a queen."
        ],
		"Constraints": [
			"1 <= n <= 9"
        ]
	},
	{
		"Title":       "Maximum Subarray",
		"Difficulty":  "Easy",
		"Description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
		"Hints": [
			"Consider using Kadane's algorithm to solve this problem efficiently.",
			"Think about how to keep track of the current maximum subarray sum as you iterate through the array."
        ],
		"Constraints": [
			"1 <= nums.length <= 3 * 10^4",
			"-10^5 <= nums[i] <= 10^5"
        ]
	},
	{
		"Title":       "Spiral Matrix",
		"Difficulty":  "Medium",
		"Description": "Given an m x n matrix, return all elements of the matrix in spiral order.",
		"Hints": [
			"Consider simulating the process of moving in a spiral order through the matrix.",
			"Think about how to handle boundary conditions and direction changes efficiently."
        ],
		"Constraints": [
			"m == matrix.length",
			"n == matrix[i].length",
			"1 <= m, n <= 10",
			"-100 <= matrix[i][j] <= 100"
        ]
	},
	{
		"Title":       "Jump Game",
		"Difficulty":  "Medium",
		"Description": "Given an array of non-negative integers nums, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nDetermine if you can reach the last index.",
		"Hints": [
			"Use a greedy approach to keep track of the furthest reachable index.",
			"Consider how to iterate through the array and update the maximum reachable index at each step."
        ],
		"Constraints": [
			"1 <= nums.length <= 10^4",
			"0 <= nums[i] <= 10^5"
        ]
	},
	{
		"Title":       "Merge Intervals",
		"Difficulty":  "Medium",
		"Description": "Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
		"Hints": [
			"Sort the intervals based on their start times to simplify the merging process.",
			"Iterate through the sorted intervals and merge overlapping intervals."
        ],
		"Constraints": [
			"1 <= intervals.length <= 10^4",
			"intervals[i].length == 2",
			"0 <= start_i <= end_i <= 10^4"
        ]
	},
	{
		"Title":       "Insert Interval",
		"Difficulty":  "Hard",
		"Description": "Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\n\nYou may assume that the intervals were initially sorted according to their start times.",
		"Hints": [
			"Sort the intervals based on their start times to simplify the insertion process.",
			"Consider how to handle the merging of intervals after inserting the new interval."
        ],
		"Constraints": [
			"0 <= intervals.length <= 10^4",
			"intervals[i].length == 2",
			"0 <= intervals[i][0] <= intervals[i][1] <= 10^5",
			"intervals is sorted by intervals[i][0] in ascending order."
        ]
	},
	{
		"Title":       "Length of Last Word",
		"Difficulty":  "Easy",
		"Description": "Given a string s consisting of some words separated by some number of spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.",
		"Hints": [
			"Trim the trailing and leading spaces of the string before processing.",
			"Scan the string from the end to find the last word and calculate its length."
        ],
		"Constraints": [
			"1 <= s.length <= 10^4",
			"s consists of only English letters and spaces ' '.",
			"There will be at least one word in s."
        ]
	},
	{
		"Title":       "Spiral Matrix II",
		"Difficulty":  "Medium",
		"Description": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n^2 in spiral order.",
		"Hints": [
			"Simulate the process of filling the matrix in spiral order.",
			"Keep track of the boundaries and direction changes while filling the matrix."
        ],
		"Constraints": [
			"1 <= n <= 20"
        ]
	},
	{
		"Title":       "Permutation Sequence",
		"Difficulty":  "Medium",
		"Description": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations.\nBy listing and labeling all of the permutations in order, return the kth permutation sequence.",
		"Hints": [
			"Use a factorial-based approach to determine the digit at each position.",
			"Consider how to efficiently find and construct the kth permutation sequence."
        ],
		"Constraints": [
			"1 <= n <= 9",
			"1 <= k <= n!"
        ]
	}
]